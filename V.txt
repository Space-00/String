Program a cli app that uses sing-box and name it "Chain", my os is windows

features:

1. the abillity to fetch configs from a subscription link

2. the ability to test configs

3. an option that lets me set my device proxy to sing-box without the need of manually setting it

4. the ability to create chain proxy cinfigs, I can create chain proxies with 2 configs, the second config in the chain has to connect via the first config (i have to connect to the second config)

5. it has to support any config




package main

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"time"

	"golang.org/x/sys/windows/registry"
)

const (
	singBoxURL     = "https://github.com/SagerNet/sing-box/releases/download/v1.8.0/sing-box_1.8.0_windows_amd64.exe"
	singBoxPath    = "sing-box.exe"
	defaultPort    = 1080
	defaultAddress = "127.0.0.1"
)

func main() {
	if len(os.Args) < 2 {
		usage()
		os.Exit(1)
	}

	command := os.Args[1]
	args := os.Args[2:]

	err := ensureSingBox()
	if err != nil {
		log.Fatalf("Failed to ensure sing-box: %v", err)
	}

	switch command {
	case "fetch":
		if len(args) != 1 {
			log.Fatal("Usage: chain fetch <subscription_url>")
		}
		err := fetchConfigs(args[0])
		if err != nil {
			log.Fatalf("Fetch failed: %v", err)
		}
	case "test":
		if len(args) != 1 {
			log.Fatal("Usage: chain test <config_file>")
		}
		err := testConfig(args[0])
		if err != nil {
			log.Fatalf("Test failed: %v", err)
		} else {
			fmt.Println("Test passed")
		}
	case "chain":
		if len(args) != 3 {
			log.Fatal("Usage: chain chain <config1> <config2> <output>")
		}
		err := createChainConfig(args[0], args[1], args[2])
		if err != nil {
			log.Fatalf("Chain creation failed: %v", err)
		}
	case "run":
		runCmd := flag.NewFlagSet("run", flag.ExitOnError)
		setProxy := runCmd.Bool("set-proxy", false, "Set system proxy")
		runCmd.Parse(args)
		if runCmd.NArg() != 1 {
			log.Fatal("Usage: chain run [--set-proxy] <config_file>")
		}
		err := runConfig(runCmd.Arg(0), *setProxy)
		if err != nil {
			log.Fatalf("Run failed: %v", err)
		}
	case "set-proxy":
		if len(args) != 0 {
			log.Fatal("Usage: chain set-proxy")
		}
		err := setSystemProxy(true)
		if err != nil {
			log.Fatalf("Set proxy failed: %v", err)
		}
		fmt.Println("System proxy set")
	case "unset-proxy":
		if len(args) != 0 {
			log.Fatal("Usage: chain unset-proxy")
		}
		err := setSystemProxy(false)
		if err != nil {
			log.Fatalf("Unset proxy failed: %v", err)
		}
		fmt.Println("System proxy unset")
	default:
		usage()
		os.Exit(1)
	}
}

func usage() {
	fmt.Println(`Chain CLI App - Uses sing-box for proxy management on Windows

Commands:
  fetch <subscription_url>              Fetch configs from subscription link and save as config_*.json
  test <config_file>                    Test a config by running sing-box and checking connectivity
  chain <config1> <config2> <output>    Create a chained config where second connects via first
  run [--set-proxy] <config_file>       Run sing-box with the config (optionally set system proxy)
  set-proxy                             Manually set system proxy to sing-box (assumes running on 127.0.0.1:1080)
  unset-proxy                           Manually unset system proxy`)
}

func ensureSingBox() error {
	if _, err := os.Stat(singBoxPath); err == nil {
		return nil
	}
	if runtime.GOOS != "windows" {
		return errors.New("this app is for Windows only")
	}
	resp, err := http.Get(singBoxURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return errors.New("failed to download sing-box")
	}
	f, err := os.Create(singBoxPath)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = io.Copy(f, resp.Body)
	return err
}

func fetchConfigs(subURL string) error {
	resp, err := http.Get(subURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	// Try base64 decode
	decoded, err := base64.StdEncoding.DecodeString(string(body))
	if err != nil {
		decoded = body // Not base64, use raw
	}

	lines := strings.Split(string(decoded), "\n")
	for i, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		// Each line might be base64 encoded JSON
		configData, err := base64.StdEncoding.DecodeString(line)
		if err != nil {
			configData = []byte(line) // Not base64
		}

		// Validate if JSON
		var temp interface{}
		if json.Unmarshal(configData, &temp) != nil {
			continue // Skip invalid
		}

		filename := fmt.Sprintf("config_%d.json", i+1)
		err = os.WriteFile(filename, configData, 0644)
		if err != nil {
			return err
		}
		fmt.Printf("Saved %s\n", filename)
	}
	return nil
}

func testConfig(configFile string) error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cmd := exec.CommandContext(ctx, singBoxPath, "run", "-c", configFile)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Start(); err != nil {
		return err
	}
	defer cmd.Process.Kill()

	// Wait a bit for startup
	time.Sleep(2 * time.Second)

	// Test connectivity through proxy
	proxyURL, _ := url.Parse(fmt.Sprintf("http://%s:%d", defaultAddress, defaultPort))
	client := &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		},
		Timeout: 10 * time.Second,
	}
	resp, err := client.Get("https://www.google.com")
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusFound {
		return errors.New("unexpected status: " + resp.Status)
	}
	return nil
}

func createChainConfig(config1, config2, output string) error {
	conf1Data, err := os.ReadFile(config1)
	if err != nil {
		return err
	}
	conf2Data, err := os.ReadFile(config2)
	if err != nil {
		return err
	}

	var conf1Map map[string]interface{}
	if err := json.Unmarshal(conf1Data, &conf1Map); err != nil {
		return err
	}
	var conf2Map map[string]interface{}
	if err := json.Unmarshal(conf2Data, &conf2Map); err != nil {
		return err
	}

	// Get outbounds
	outbounds1, ok := conf1Map["outbounds"].([]interface{})
	if !ok || len(outbounds1) == 0 {
		return errors.New("no outbounds in config1")
	}
	outbounds2, ok := conf2Map["outbounds"].([]interface{})
	if !ok || len(outbounds2) == 0 {
		return errors.New("no outbounds in config2")
	}

	// Set tags
	outbound1 := outbounds1[0].(map[string]interface{})
	outbound1["tag"] = "proxy1"

	outbound2 := outbounds2[0].(map[string]interface{})
	outbound2["tag"] = "proxy2"
	outbound2["detour"] = "proxy1"

	// Create new outbounds: combine
	newOutbounds := []interface{}{outbound1, outbound2}
	for i := 1; i < len(outbounds1); i++ {
		newOutbounds = append(newOutbounds, outbounds1[i])
	}
	for i := 1; i < len(outbounds2); i++ {
		newOutbounds = append(newOutbounds, outbounds2[i])
	}

	// Merge configs, prefer config2
	newConf := make(map[string]interface{})
	for k, v := range conf1Map {
		newConf[k] = v
	}
	for k, v := range conf2Map {
		newConf[k] = v
	}
	newConf["outbounds"] = newOutbounds

	// Handle route
	route, ok := newConf["route"].(map[string]interface{})
	if !ok {
		route = make(map[string]interface{})
		newConf["route"] = route
	}
	route["final"] = "proxy2"

	// Handle if there are rules, update any "outbound": "proxy" to "proxy2" as best effort
	rules, ok := route["rules"].([]interface{})
	if ok {
		for _, r := range rules {
			rule := r.(map[string]interface{})
			if ob, ok := rule["outbound"].(string); ok && ob == "proxy" {
				rule["outbound"] = "proxy2"
			}
		}
	}

	newData, err := json.MarshalIndent(newConf, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(output, newData, 0644)
}

func runConfig(configFile string, setSysProxy bool) error {
	absConfig, err := filepath.Abs(configFile)
	if err != nil {
		return err
	}

	cmd := exec.Command(singBoxPath, "run", "-c", absConfig)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true} // Run hidden on Windows

	if err := cmd.Start(); err != nil {
		return err
	}

	if setSysProxy {
		if err := setSystemProxy(true); err != nil {
			cmd.Process.Kill()
			return err
		}
		defer setSystemProxy(false)
	}

	// Wait for interrupt
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	cmd.Process.Kill()
	return nil
}

func setSystemProxy(enable bool) error {
	k, err := registry.OpenKey(registry.CURRENT_USER, `Software\Microsoft\Windows\CurrentVersion\Internet Settings`, registry.SET_VALUE)
	if err != nil {
		return err
	}
	defer k.Close()

	if enable {
		proxyStr := fmt.Sprintf("http://%s:%d", defaultAddress, defaultPort)
		if err := k.SetDWordValue("ProxyEnable", 1); err != nil {
			return err
		}
		if err := k.SetStringValue("ProxyServer", proxyStr); err != nil {
			return err
		}
	} else {
		if err := k.SetDWordValue("ProxyEnable", 0); err != nil {
			return err
		}
		if err := k.DeleteValue("ProxyServer"); err != nil && err != registry.ErrNotExist {
			return err
		}
	}

	// Notify system of change
	var hwnd syscall.Handle
	var msg uint32 = 0x001A // WM_SETTINGCHANGE
	lparam, _ := syscall.UTF16PtrFromString("Environment")
	syscall.SendMessageTimeout(syscall.HWND_BROADCAST, msg, 0, uintptr(unsafe.Pointer(lparam)), 0, 1000, &hwnd)
	return nil
}
